<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>wsl-arch-vscode manual</title>
    <link href="/2025/03/24/wslmanual/"/>
    <url>/2025/03/24/wslmanual/</url>
    
    <content type="html"><![CDATA[<h1 id="wsl-arch-vscode-manual"><a href="#wsl-arch-vscode-manual" class="headerlink" title="wsl-arch-vscode manual"></a>wsl-arch-vscode manual</h1><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241352823.png" alt="wsl鬼图"></p><h1 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h1><h3 id="windows设置：开启wsl"><a href="#windows设置：开启wsl" class="headerlink" title="windows设置：开启wsl"></a>windows设置：开启wsl</h3><ul><li><p>wsl选项功能打开</p><p>  <a href="https://blog.cls.ink/2024/10/18/WSL2-SpeedRun/">WSL2 SpeedRun Any% - MrBeanC-Blog</a> 😊</p></li></ul><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241352166.png" alt="设置开启wsl功能"></p><ul><li>powershell：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl install — no distribution<br></code></pre></td></tr></table></figure><ul><li>安装nerd font<ul><li>windows安装字体的方法：<a href="https://support.microsoft.com/en-us/office/add-a-font-b7c5f17c-4426-4b53-967f-455339c564c1">Add a font - Microsoft Support</a></li></ul></li></ul><h1 id="arch安装"><a href="#arch安装" class="headerlink" title="arch安装"></a>arch安装</h1><h2 id="解压安装和设置root用户"><a href="#解压安装和设置root用户" class="headerlink" title="解压安装和设置root用户"></a>解压安装和设置root用户</h2><p><a href="https://github.com/yuk7/ArchWSL">https://github.com/yuk7/ArchWSL</a></p><ul><li><p>下载release版本中 arch.zip，解压到某个目录下，作为存放硬盘映像的位置</p><ul><li><code>Arch.exe</code>的文件名可以自行修改，作为命名该wsl实例的名字，在终端会显示一致的命名</li></ul></li><li><p>双击<code>$&#123;Archname&#125;.exe</code>，安装roofts</p><ul><li>该目录中会多出一个硬盘映像文件，会随着使用而体积变大</li></ul></li><li><p>再次双击<code>$&#123;Archname&#125;.exe</code>，设置root和root password</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd<br></code></pre></td></tr></table></figure></li></ul><h2 id="设置日常用户"><a href="#设置日常用户" class="headerlink" title="设置日常用户"></a>设置日常用户</h2><ul><li><p><strong>Arch终端中</strong>打开并设置sudoers file</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;%wheel ALL=(ALL) ALL&quot;</span> &gt; /etc/sudoers.d/wheel<br></code></pre></td></tr></table></figure><ul><li>添加日常用户名 和 对应用户的密码</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">useradd -m -G wheel -s /bin/bash &#123;username&#125;<br></code></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd &#123;username&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>powershell终端</strong>中，在<code>$&#123;Archname&#125;.exe</code>所在目录打开</p><ul><li>设置默认为日常用户</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.\Arch1.exe config --default-user &#123;username&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>会遇到报错说：wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。</p><ul><li>这是因为网络模式默认是NAT</li><li>这种情况下在powershell打开arch目录设置<code>.\Arch1.exe config --default-user matoka</code> 会报错说<code>ERR: wsl: �hKm0R localhost �NtM�n</code></li></ul></blockquote><ul><li><p>需要在<code>C:\Users\&#123;username&#125;</code> 下设置<code>.wslconfig</code>来更改网络配置</p><ul><li><p>首先关闭所有wsl运行的实例，可以选择在Arch终端下<code>exit</code></p></li><li><p>也可以在powershell中</p><ul><li><p>关闭所有正在运行的发行版</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure></li><li><p>关闭特定的发行版</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --terminate &lt;distroName&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>powershell查看正在运行的发行版</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --list --running<br></code></pre></td></tr></table></figure></li><li><p><code>C:\Users\&#123;username&#125;\.wslconfig</code> 中配置网络部分设置</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Enable experimental features</span><br>[experimental]<br>autoMemoryReclaim=gradual  <br>networkingMode=mirrored<br>dnsTunneling=<span class="hljs-literal">true</span><br>firewall=<span class="hljs-literal">true</span><br>autoProxy=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p><a href="https://learn.microsoft.com/en-us/windows/wsl/wsl-config#configure-global-options-with-wslconfig">Advanced settings configuration in WSL | Microsoft Learn</a></p></li></ul></li><li><p>Tips：发现从终端下拉选择企鹅头 Arch打开 和 从<code>$&#123;Archname&#125;.exe</code>所在目录双击<code>$&#123;Archname&#125;.exe</code> 得到的终端的光标前提示符不同</p><p>  <img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241352441.jpg" alt="从终端的wsl选项卡打开"></p><p>  <img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241352994.png" alt="从exe所在目录打开"></p><ul><li>从文件资源管理器的.exe所在目录打开，则提示了当前的工作目录是<code>D:\32417101\wsl\arch-1\Arch</code> ；在 Linux 中，<code>~</code> 是一个快捷符号，指向当前用户的主目录（如 <code>/home/username</code>）</li></ul></li></ul><p>联网</p><p>开发ide环境 neo vim &#x2F; vscode </p><p>windows文件共享</p><p>汉字输入法</p><h2 id="pacman初始化和安装包"><a href="#pacman初始化和安装包" class="headerlink" title="pacman初始化和安装包"></a>pacman初始化和安装包</h2><ul><li>在文件资源管理器中打开<code>$&#123;Archname&#125;.exe</code>  <img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241353042.jpg" alt="pacman密钥环">  输入下列命令  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[user@PC-NAME]$ sudo pacman-key --init<br><br>[user@PC-NAME]$ sudo pacman-key --populate<br><br>[user@PC-NAME]$ sudo pacman -Sy archlinux-keyring<br><br><span class="hljs-comment"># 更新所有的包</span><br>[user@PC-NAME]$ sudo pacman -Su<br></code></pre></td></tr></table></figure><ul><li>以前的视频里面，up展示的包有三个有community，现在community已经没了</li></ul><p>  <img src="/image%203.png" alt="image.png"></p><p>  <img src="/03f66b51e0043199153a8cd18ec956e.jpg" alt="pacman"></p></li></ul><h2 id="配置开发环境（C-CMake）"><a href="#配置开发环境（C-CMake）" class="headerlink" title="配置开发环境（C++ CMake）"></a>配置开发环境（C++ CMake）</h2><h2 id="使用vscode-in-windows-wsl-到-arch"><a href="#使用vscode-in-windows-wsl-到-arch" class="headerlink" title="使用vscode(in windows) wsl 到 arch"></a>使用vscode(in windows) wsl 到 arch</h2><ul><li>windows上安装vscode，并且安装wsl拓展</li><li>用wsl连接到arch的时候，一定要先确保arch的终端开着<ul><li><p>不然会有迷の报错：</p><p>  <img src="/image%204.png" alt="error"></p></li><li><p>但是并不需要手动去wsl终端输入任何命令安装vscode</p></li></ul></li></ul><h2 id="arch中安装所需要的软件包（GCC含G-GDB-CMake-和-）"><a href="#arch中安装所需要的软件包（GCC含G-GDB-CMake-和-）" class="headerlink" title="arch中安装所需要的软件包（GCC含G++ GDB CMake  和 ???）"></a>arch中安装所需要的软件包（GCC含G++ GDB CMake  和 ???）</h2><ul><li><p>首先确保已有的所有包都能同步更新</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Syu<br></code></pre></td></tr></table></figure></li><li><p>看看包含些什么包（假装pro）（其实啥也没看明白._.）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Ss gcc<br></code></pre></td></tr></table></figure></li><li><p>正式安装</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S gcc<br></code></pre></td></tr></table></figure></li><li><p>验证查看版本</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc --version<br></code></pre></td></tr></table></figure></li><li><p>重复上述的步骤来安装<code>gdb</code>和 <code>cmake</code></p></li></ul><p>Ref: <a href="https://cn.linux-console.net/?p=15089">如何为 Arch Linux 安装 GCC</a></p><p>Ref: 常见的pacman指令见<a href="https://wiki.archlinux.org/title/Pacman">pacman - ArchWiki</a></p><ul><li>这里我一开始漏装了一个东西 （build tool）比如<code>make</code> 和 <code>ninja</code></li></ul><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241353555.png" alt="extension list"></p><h2 id="vscode-（windows端）安装extension-到-wsl"><a href="#vscode-（windows端）安装extension-到-wsl" class="headerlink" title="vscode （windows端）安装extension 到 wsl"></a>vscode （windows端）安装extension 到 wsl</h2><ul><li><p>连接到wsl后，点击extension，会发现有两个分区，显示一部分是local（windows端），一部分是wsl；拓展的后面都有一个install in wsl（没有<strong>ed</strong>结尾，证明此时wsl里面什么拓展都没有)</p></li><li><p>vscode中的拓展工作原理：是基于host系统里面已经安装了各种底层的工具（比如编译器组件，比如cmake）因此<strong>vscode的对应拓展</strong>以及刚才在<strong>arch安装的工具</strong>，<strong>两者都是需要</strong>的（如果只有arch上安装的工具，没办法用vscode的.vscode来进行命令（即通过json来控制底层这些工具的指令高效构建和运行等）</p><ul><li>可以理解为vscode的拓展是给对应的工具套了一个壳子接口，方便用户管理</li></ul></li><li><p>需要安装的拓展：C&#x2F;C++ , cmake tools intelliSense</p></li><li><p>在arch用户目录下新建项目目录，并创建第一个项目目录test，在里面新建文件test.cpp</p></li><li><p>.cpp对应的编译器选择是g++（不要选错成gcc，否则就会找不到c++库的函数std::cout）</p></li><li><p>如果忘了装make或者ninja的话，build 运行之后会报错</p><p>  <img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241353842.png" alt="CMake error"></p><ul><li><p>需要安装ninja或者make；如果是ninja，需要设置cmake的prefered generator为ninja；但是貌似ui设置的不一定会映射到json里面</p><p>  <img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241353447.png" alt="ca28d36c-a5cd-4f20-8d46-64c7284082d0.png"></p><p>  <img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241354483.png" alt="settings.json"></p><p>  Ref: <a href="https://zhuanlan.zhihu.com/p/7346544263">如何在VSCode中“优雅”地配置CMake —— 以PaddlePaddle为例 - 知乎</a></p></li></ul></li><li><p>关于vscode中的json配置（首选用UI进行选项配置）</p><p>  <img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241354220.png" alt="d299a350-7aea-4a0f-b18e-8a7eafca7064.png"></p><p>  <img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202503241354293.png" alt="hello world"></p></li></ul><p>Ref: <a href="https://code.visualstudio.com/docs/cpp/config-linux">Using C++ on Linux in VS Code</a></p><p>Ref: <a href="https://code.visualstudio.com/docs/cpp/c-cpp-properties-schema-reference">c_cpp_properties.json reference</a></p><p>Ref: <a href="https://code.visualstudio.com/docs/cpp/cmake-linux">Get started with CMake Tools on Linux</a></p>]]></content>
    
    
    <categories>
      
      <category>部署manual</category>
      
    </categories>
    
    
    <tags>
      
      <tag>wsl</tag>
      
      <tag>ArchLinux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02.0.智能指针与RAII思想</title>
    <link href="/2024/10/28/RAII%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2024/10/28/RAII%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="02-0-智能指针与RAII思想"><a href="#02-0-智能指针与RAII思想" class="headerlink" title="02.0.智能指针与RAII思想"></a>02.0.智能指针与RAII思想</h1><h2 id="不可滥用封装——封装的目的是维护相关属性的不变性"><a href="#不可滥用封装——封装的目的是维护相关属性的不变性" class="headerlink" title="不可滥用封装——封装的目的是维护相关属性的不变性"></a>不可滥用封装——封装的目的是维护相关属性的不变性</h2><p>正面例子：vector</p><ul><li>由于对单个元素的增删操作会影响到vector的size以及资源分配大小，因此需要打包操作作为一个原子（不可分割）来避免程序员疏忽犯错</li></ul><p>反面例子：三元tuple使用封装 (x)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vec3</span>&#123;<br><span class="hljs-type">float</span> x,y,z;<br>&#125;<br><span class="hljs-comment">// struct足够，不需要class和getX setX方法</span><br></code></pre></td></tr></table></figure><ul><li>不需要对一个<code>(x,y,z)</code>写<code>getter</code>和<code>setter</code>因为彼此是独立的</li></ul><h3 id="封装类——构造函数"><a href="#封装类——构造函数" class="headerlink" title="封装类——构造函数"></a>封装类——构造函数</h3><p>成员初始化列表member list initializer: </p><ul><li>const，reference成员必须在类构造之前初始化，必须用成员列表initialize</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> constantValue;       <span class="hljs-comment">// const 成员</span><br>    std::string&amp; referenceMember;  <span class="hljs-comment">// 引用成员</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，使用成员初始化列表对 const 和引用成员进行初始化</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value, std::string&amp; ref)<br>        : <span class="hljs-built_in">constantValue</span>(value), <span class="hljs-built_in">referenceMember</span>(ref) &#123;<br>        <span class="hljs-comment">// 构造函数主体</span><br>       <br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>避免重复初始化，更高效</li></ul><p><code>explicit</code>修饰构造函数:</p><ul><li>单参数时：禁止隐式的类型转换</li><li>多参数时：（同单参数）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pig</span> &#123;<br>    std::string m_name;<br>    <span class="hljs-type">int</span> m_weight;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Pig</span><span class="hljs-params">(std::string name, <span class="hljs-type">int</span> weight)</span></span><br><span class="hljs-function">        : m_name(name)</span><br><span class="hljs-function">        , m_weight(weight)</span><br><span class="hljs-function">    &#123;</span>&#125;<br><br>    <span class="hljs-built_in">Pig</span>(Pig <span class="hljs-type">const</span> &amp;other) = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Pig pig)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;name: &quot;</span> &lt;&lt; pig.m_name &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;weight: &quot;</span> &lt;&lt; pig.m_weight &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">show</span>(&#123;<span class="hljs-string">&quot;pig1&quot;</span>,<span class="hljs-number">20</span>&#125;); <span class="hljs-comment">//编译不通过 如果去掉explicit 可以执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：并不是绝对的要always加上<code>explicit</code> sometimes需要隐式类型转换带来方便哦</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// QString(const char *str); 没有explicit 所以支持隐式转换</span><br>QString str = <span class="hljs-string">&quot;Hello, world!&quot;</span>; <span class="hljs-comment">// 隐式转换 const char* 到 QString</span><br></code></pre></td></tr></table></figure><p>Ref: <a href="https://en.cppreference.com/w/cpp/language/constructor">构造函数和成员初始值设定项列表 - cppreference.com — Constructors and member initializer lists - cppreference.com</a></p><p>() vs {}——cast类型小心丢失精度:</p><ul><li>()强制类型转换，{}更加安全</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">int</span>(<span class="hljs-number">3.14f</span>) <span class="hljs-comment">//不出错</span><br><span class="hljs-type">int</span>&#123;<span class="hljs-number">3.14f</span>&#125; <span class="hljs-comment">//报错 &#123;&#125;是非强制转换</span><br><span class="hljs-comment">//推荐使用：</span><br><span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3.14f</span>);<br><span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(<span class="hljs-number">0xb8000</span>);<br></code></pre></td></tr></table></figure><p>使用编译器的对类的默认构造函数时：</p><ul><li>这些成员类型不会被初始化为 0：<ul><li>int, float, double 等基础类型</li><li>void *, Object * 等指针类型</li><li>完全由这些类型组成的类</li></ul></li><li>这些类型被称为 <strong>POD（plain-old-data）</strong></li></ul><p>应用例子——光线追踪函数返回值有多个属性时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HitRes</span>&#123;<br><span class="hljs-type">bool</span> hit;<br>Vec3 pos;<br>Vec3 normal;<br><span class="hljs-type">float</span> depth;<br>&#125;;<br><span class="hljs-function">HitRes <span class="hljs-title">intersect</span><span class="hljs-params">(Ray r)</span> </span>&#123;<br><span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">true</span>, r.origin, r.direction, <span class="hljs-number">233.0f</span>&#125;<br>&#125;<br><span class="hljs-comment">// or </span><br><span class="hljs-keyword">struct</span> HitRes&#123;<br><span class="hljs-type">bool</span> hit;<br>Vec3 pos;<br>Vec3 normal;<br><span class="hljs-type">float</span> depth;<br>&#125; <span class="hljs-built_in">intersect</span>(Ray r) &#123;<br><span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">true</span>, r.origin, r.direction, <span class="hljs-number">233.0f</span>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-built_in">main</span>()&#123;<br>Ray r;<br><span class="hljs-keyword">auto</span> hit = <span class="hljs-built_in">intersect</span>(r);<br><span class="hljs-keyword">if</span>(hit.hit)&#123;<br>r.origin = hit.pos;<br>r.direction = hit.normal;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>和tuple相比，{}会有名字</li></ul><h3 id="三五法则："><a href="#三五法则：" class="headerlink" title="三五法则："></a>三五法则：</h3><p>适用于管理资源的类（如diy的vector类）</p><ul><li>如果一个类定义了解构函数，那么您必须同时定义或删除拷贝构造函数和拷贝赋值函数，否则出错。</li><li>如果一个类定义了拷贝构造函数，那么您必须同时定义或删除拷贝赋值函数，否则出错，删除可导致低效。</li><li>如果一个类定义了移动构造函数，那么您必须同时定义或删除移动赋值函数，否则出错，删除可导致低效。</li><li>如果一个类定义了拷贝构造函数或拷贝赋值函数，那么您必须最好同时定义移动构造函数或移动赋值函数，否则低效。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span>&#123;<br><span class="hljs-built_in">C</span>();<br><span class="hljs-built_in">C</span>(C <span class="hljs-type">const</span> &amp;c);<br><span class="hljs-built_in">C</span>(C &amp;&amp;c);<br>C &amp;<span class="hljs-keyword">operator</span>=(C <span class="hljs-type">const</span> &amp;c);<br>C &amp;<span class="hljs-keyword">operator</span>=(C &amp;&amp;c);<br>~<span class="hljs-built_in">C</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>由于自动生成的拷贝赋值和构造对于智能指针是浅拷贝 因此下面情况可能会double free 甚至别的情况中，如果vec2提前释放的话，vec1是悬垂指针dangling pointer更加危险</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>Vector vec1;<br><span class="hljs-function">Vector <span class="hljs-title">vec2</span><span class="hljs-params">(vec1)</span></span>;<br>Vector vec3 = vec1;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 自动释放vec1，2，3</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>为了统一拷贝时是深拷贝 移动的时候统一逻辑</p></li><li><p>为了统一拷贝时是深拷贝 移动的时候统一逻辑</p></li><li><p>移动会更高效</p></li></ol><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>不可以被拷贝，如果要作为参数传递给函数可选择：</p><ul><li><code>func(p.get());</code> 用于不改变p的生命周期，不会接管p的ownership<ul><li>但是需要注意不能在func内部去释放掉p指向的资源</li></ul></li><li><code>func(std::move(p));</code> 用于改变p的生命周期，take原本的ownership（此时外部的p已经指向nullptr）</li></ul><h3 id="shared-ptr-和-weak-ptr"><a href="#shared-ptr-和-weak-ptr" class="headerlink" title="shared_ptr 和 weak_ptr"></a>shared_ptr 和 weak_ptr</h3><ul><li><code>C*</code> 理解为 <code>unique_ptr</code> 的弱引用。</li><li><code>weak_ptr</code> 理解为 <code>shared_ptr</code> 的弱引用。但 <code>weak_ptr</code> 能提供失效检测，更安全。</li></ul><p>shared_ptr维护的use_count</p><blockquote><p>In a typical implementation, <code>shared_ptr</code> holds only two pointers:在典型的实现中， <code>shared_ptr</code>仅保存两个指针：</p><ul><li><p>the stored pointer (one returned by <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/get">get()</a>);</p><p>存储的指针（由<a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/get">get()</a>返回的指针）；</p></li><li><p>a pointer to <em>control block</em>.</p><p>指向<em>控制块的</em>指针。{control block包含：</p><ul><li><p>either a pointer to the managed object or the managed object itself;</p><p>指向托管对象的指针或托管对象本身；</p></li><li><p>the deleter (type-erased);</p><p>删除器（类型擦除）；</p></li><li><p>the allocator (type-erased);</p><p>分配器（类型擦除）；</p></li><li><p>the number of <code>shared_ptr</code>s that own the managed object;</p><p>拥有托管对象的<code>shared_ptr</code>的数量；</p></li><li><p>the number of <code>weak_ptr</code>s that refer to the managed object.</p><p>引用托管对象的<code>weak_ptr</code>的数量。</p><p>}</p></li></ul></li></ul></blockquote><p>Ref: <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr - cppreference.com — std::shared_ptr - cppreference.com</a></p><ul><li>创建自身时: +1</li><li>被其他对象持有或者拷贝给了另一个shared_ptr: +1</li></ul><p>只有当所有指向该对象的 <code>shared_ptr</code> 被销毁，引用计数降为 0 时，控制块才会销毁对象。</p><p><strong>如何让一个weak_ptr指向一个Node的指针</strong></p><ul><li>weak_ptr可以指向shared_ptr</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> : std::enable_shared_from_this&lt;Node&gt;&#123;<br>    std::shared_ptr&lt;Node&gt; next;<br>    std::weak_ptr&lt;Node&gt; prev;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        value = val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> node = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(val);<br>        node-&gt;prev = <span class="hljs-built_in">shared_from_this</span>();<br>        node-&gt;next = next;<br>        <span class="hljs-keyword">this</span>-&gt;next = node;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (next)<br>            next-&gt;prev = prev;<br>        <span class="hljs-keyword">if</span> (!prev.<span class="hljs-built_in">expired</span>()) &#123;<br>            prev.<span class="hljs-built_in">lock</span>()-&gt;next= next;  <br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Node</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;~Node()\n&quot;</span>);   <br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> node_weak = std::<span class="hljs-built_in">weak_ptr</span>&lt;Node&gt;();<br>node_weak = node1;<br>std::cout &lt;&lt; node_weak.<span class="hljs-built_in">lock</span>()-&gt;value &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><ul><li>weak_ptr不可以指向一个裸object指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> : std::enable_shared_from_this&lt;Node&gt;&#123;<br>    <span class="hljs-comment">// enable shared使得可以获取object的shared指针</span><br>    std::shared_ptr&lt;Node&gt; next;<br>    std::weak_ptr&lt;Node&gt; prev;<br><br>    <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        value = val;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">auto</span> node = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(val);<br><span class="hljs-comment">// node-&gt;prev = std::shared_ptr&lt;Node&gt;(this); //酱紫会报错</span><br><span class="hljs-comment">// node-&gt;next = this; //酱紫不过编译 No viable operator= matches arguments of type std::shared_ptr&lt;Node&gt; and Node *.</span><br>  node-&gt;next = next;<br>  <span class="hljs-keyword">this</span>-&gt;next = node;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>std::weak_ptr</code> is a smart pointer that holds a non-owning (“weak”) reference to an object that is managed by <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a>. It must be converted to <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> in order to access the referenced object.</p></blockquote><p>Ref: <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr">std::weak_ptr - cppreference.com — std::weak_ptr - cppreference.com</a></p><blockquote><p>在类内部如果需要获取当前对象的 <code>shared_ptr</code>，应该使类继承 <strong><code>std::enable_shared_from_this</code></strong></p></blockquote><p>Ref: <a href="https://stackoverflow.com/questions/712279/what-is-the-usefulness-of-enable-shared-from-this">c++ - <code>enable_shared_from_this</code> 有什么用处？ - 堆栈溢出 — c++ - What is the usefulness of <code>enable_shared_from_this</code>? - Stack Overflow</a></p><p><a href="https://learn.microsoft.com/en-us/cpp/standard-library/enable-shared-from-this-class?view=msvc-170">启用_shared_from_this 类 |微软学习 — enable_shared_from_this Class | Microsoft Learn</a></p><ul><li>正面例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>(); <span class="hljs-comment">// 使用 enable_shared_from_this 的正确方式</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass instance&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 正确方式：使用 std::make_shared 创建 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br><br>    <span class="hljs-comment">// 使用成员函数创建另一个共享的 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj2 = obj1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 address&quot;</span> &lt;&lt; obj1.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 address&quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <span class="hljs-comment">//是一样的</span><br>    <span class="hljs-comment">// 输出引用计数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 use_count: &quot;</span> &lt;&lt; obj1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 2</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 use_count: &quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这种东东不会造成循环引用，<code>obj1</code>和<code>obj2</code>的关系并非互相持有，而是共同拥有控制块<ul><li>可以简单的理解为这是<code>shared_ptr</code>发生了拷贝行为</li></ul></li><li>反面例子：(x)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 错误：直接用 this 创建新的 shared_ptr</span><br>&#125;<br><span class="hljs-comment">// 统一用shared_ptr的写法保证了debug视图control block显示的一致</span><br>std::shared_ptr&lt;MyClass&gt; obj1 = std::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="hljs-keyword">new</span> MyClass);<br>std::shared_ptr&lt;MyClass&gt; obj2 = obj1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 address&quot;</span> &lt;&lt; obj1.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <br>std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 address&quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <span class="hljs-comment">//是一样的</span><br><span class="hljs-comment">// 输出引用计数</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 use_count: &quot;</span> &lt;&lt; obj1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 1</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 use_count: &quot;</span> &lt;&lt; obj2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 1</span><br></code></pre></td></tr></table></figure><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="不继承enabled-shared-from-this-企图一个对象有多个shared-ptr-x"><a href="#不继承enabled-shared-from-this-企图一个对象有多个shared-ptr-x" class="headerlink" title="不继承enabled_shared_from_this 企图一个对象有多个shared_ptr(x)"></a>不继承<code>enabled_shared_from_this</code> 企图一个对象有多个shared_ptr(x)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 错误：直接用 this 创建新的 shared_ptr</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass instance&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;MyClass&gt; obj1 = std::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="hljs-keyword">new</span> MyClass);<br>    <span class="hljs-comment">// 使用成员函数创建另一个共享的 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj2 = obj1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052011146.png" alt="image.png"></p><p><code>_Rep</code>是控制块</p><p>Ref: <a href="https://devblogs.microsoft.com/oldnewthing/20230814-00/?p=108597#:~:text=0x00c%20_Weaks%20%20%20%20%20%20%20%20%20%20%20%3A%201-,Here%E2%80%99s,-how%20the%20names">Inside STL: Smart pointers - The Old New Thing</a></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052011332.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052013138.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052011876.png" alt="image.png"></p><ul><li>注意到，<code>obj1</code>和<code>obj2</code>的控制块并不相同，彼此并不知道对方的存在。资源<code>_Ptr</code>只有一份，当各自的引用计数&#x3D;0时都会去删除资源，导致double free，铸成大错:(</li><li>多个shared_ptr各自初始化并指向同一个资源违反了rules：</li></ul><blockquote><p>The ownership of an object can <strong>only be</strong> shared with another<code>shared_ptr</code>by copy constructing or copy assigning its value to another<code>shared_ptr</code>. Constructing a new<code>shared_ptr</code>using the raw underlying pointer owned by another<code>shared_ptr</code>leads to undefined behavior.</p><p>对象的所有权只能通过复制构造或复制将其值分配给另一个<code>shared_ptr</code> <code>shared_ptr</code> 。使用另一个<code>shared_ptr</code>拥有的原始底层指针构造一个新的<code>shared_ptr</code>会导致未定义的行为。</p></blockquote><p>Ref: <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr - cppreference.com — std::shared_ptr - cppreference.com</a></p><p><em><strong>Sidenote——double free为什么坏？</strong></em></p><ul><li>大多数内存分配器（例如 GNU C 库的 <code>malloc</code> 实现）中，每个内存块（chunk）的元数据通常存储在块的前面几个字节中，用于记录块的大小、分配状态等信息。一般来说，<code>malloc</code> 会在用户请求的内存块前面保留额外的字节来存储这些元数据，例如块大小和其他标记信息。</li><li>当double free的时候，被free的内存chunk的size假设是存储在ptr的前面几个字节的，例如<code>auto size = *(ptr - 8);</code> 然后第一次free之后这个<code>ptr</code>已经无效了，第二次free时堆ptr-8 的解引用 可能会造成非法内存访问</li></ul><h3 id="不同shared-ptr创建方式→不同的内存布局-layout"><a href="#不同shared-ptr创建方式→不同的内存布局-layout" class="headerlink" title="不同shared_ptr创建方式→不同的内存布局(layout)"></a><strong>不同shared_ptr创建方式→不同的内存布局(layout)</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 错误：直接用 this 创建新的 shared_ptr</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass instance&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;MyClass&gt; obj1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    <span class="hljs-comment">// 使用成员函数创建另一个共享的 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj2 = obj1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052011662.png" alt="image.png"></p><ul><li><p>shared_ptr：分别给control block 和 raw pointer分配</p></li><li><p>make_shared：一次性分配堆空间（似乎性能和安全上更好）</p></li><li><h4 id="不同的构造方式将导致不同的内存布局，同时影响shared-ptr销毁时的具体行为"><a href="#不同的构造方式将导致不同的内存布局，同时影响shared-ptr销毁时的具体行为" class="headerlink" title="不同的构造方式将导致不同的内存布局，同时影响shared_ptr销毁时的具体行为"></a>不同的构造方式将导致不同的内存布局，同时影响<code>shared_ptr</code>销毁时的具体行为</h4><table><thead><tr><th>情况</th><th>Dispose()</th><th>Delete()</th></tr></thead><tbody><tr><td>通过裸指针传参构造</td><td>销毁 S 对象并释放对象内存</td><td>销毁控制块并释放控制块内存</td></tr><tr><td>通过 <code>make_shared</code> 创建</td><td>运行 S 对象的析构函数（释放对象内部资源）但不释放内存</td><td>销毁控制块并释放整个内存块（包含对象和控制块）</td></tr></tbody></table><p>这里可能会有同学好奇<code>Dispose()</code>和<code>Delete()</code>都是什么玩意儿</p><p>莫急，莫急，且听我细细道来</p><p><code>Dispose()</code>和<code>Delete()</code>是<code>Control Block</code>的两个函数，用于控制两个不同阶段的递进销毁行为</p><ul><li><code>Dispose()</code>: 该函数在最后一个<code>shared_ptr</code>析构时被调用（aka, share计数为0），用以析构被<strong>管理的对象</strong>指针（但不一定回收内存）</li><li><code>Delete()</code>: 该函数在所有关联的<code>shared_ptr</code>和<code>weak_ptr</code>均析构时被调用（aka, share计数和weak计数均归零），用以回收<strong>控制块</strong></li></ul><p>我们可以发现，这两个阶段是递进关系，<code>Dispose()</code>保留控制块的唯一理由就是怕有<code>weak_ptr</code>惦记，但如果没有，那么这两个函数应该几乎会同步顺序执行</p><p>这样一来，上文的表格相信各位客官都已经心知肚明了</p><p>在第一种情况下，<code>shared_ptr</code>通过裸指针构造，由于被管理的对象先于<code>shared_ptr</code>被创建，他们的内存分布想必也是没什么联系，那么在<code>Dispose()</code>时即可回收其内存</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411061424979.png" alt="通过shared_ptr创建"></p><p>而在第二种情况下，<strong>被管理的对象</strong>以及<code>shared_ptr</code>均通过 <code>make_shared</code>创建，那么出于优化考虑，<strong>控制块</strong>和<strong>被管理的对象</strong>是不是可以在统一分配的<strong>大块内存</strong>上构造呢</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411061424217.png" alt="通过make_shared创建"></p><p>是的，那么这种情况下，<code>Dispose()</code>肯定也就不能单独回收该对象所占用的部分内存，必须等到<code>Delete()</code>时，析构控制块后，统一回收整体内存</p><p>详情请见：<a href="https://devblogs.microsoft.com/oldnewthing/20230815-00/?p=108602">Inside STL: The shared_ptr constructor vs make_shared - The Old New Thing</a></p></li><li><p>销毁时如何释放？</p><ul><li>请参考： <a href="https://devblogs.microsoft.com/oldnewthing/20230815-00/?p=108602">STL 内部：shared_ptr 构造函数与 make_shared - 老新事物 — Inside STL: The shared_ptr constructor vs make_shared - The Old New Thing</a></li></ul></li></ul><h3 id="实验之前——预习如何看MSVC调试内存地址-●’◡’●"><a href="#实验之前——预习如何看MSVC调试内存地址-●’◡’●" class="headerlink" title="实验之前——预习如何看MSVC调试内存地址(●’◡’●)"></a>实验之前——预习如何看MSVC调试内存地址(●’◡’●)</h3><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052011121.png" alt="image.png"></p><p>系统架构是 64 位系统，因此 <code>_Ptr</code> 指针占用 <strong>8 字节</strong> 的内存空间，从 <code>0x0000014289647130</code> 到 <code>0x0000014289647138</code></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052011100.png" alt="image.png"></p><ul><li>第一行以 <code>0x000001a4a9b023b0</code> 开始，第二行以 <code>0x000001a4a9b023c0</code> 开始。</li><li>每一行的内存地址相差 <strong>16 字节</strong>（或 0x10），这表示每行显示的是连续的 16 字节的数据。</li></ul><h3 id="shared-ptr-创建方式"><a href="#shared-ptr-创建方式" class="headerlink" title="shared_ptr 创建方式"></a><code>shared_ptr</code> 创建方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        value = val;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Test object created.\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Test object destroyed.\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Test* rawPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Test</span>(<span class="hljs-number">1</span>);                       <br>    <span class="hljs-function">std::shared_ptr&lt;Test&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(rawPtr)</span></span>;<br>    std::weak_ptr&lt;Test&gt; wp2;<br>    wp2 = sp1;<br>    sp1.<span class="hljs-built_in">reset</span>();<br>    std::cout &lt;&lt; wp2.<span class="hljs-built_in">lock</span>()-&gt;value &lt;&lt;std::endl; <span class="hljs-comment">//运行时错误，访问不到value</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012503.png" alt="image.png"></p><ul><li>可以发现raw ptr和control block的内存地址并不相邻</li></ul><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012493.png" alt="raw ptr 内存地址"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012654.png" alt="control block (_Rep) 内存地址"></p><ul><li>可以发现control block后面存了一个raw ptr的地址</li></ul><p><code>sp1.reset();</code> 执行之后</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012639.png" alt="image.png"></p><p>下图是weak ptr里面的<code>_Rep</code>视图：</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012604.png" alt="control block的Uses计数 = 0  Weaks计数 - 1 = 1"></p><p>下图是weak ptr里面的raw ptr视图：</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012947.png" alt="raw ptr 已经先于control block被释放了资源了"></p><p><strong>为什么访问不到value？</strong></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012630.png" alt="expired()表示dying和dead（快要释放和已经删除释放）"></p><p><code>Test</code> 对象已经似了QAQ，连同ta地址前面的内存chunk，都是ta死亡的证明！</p><h3 id="make-shared-创建方式"><a href="#make-shared-创建方式" class="headerlink" title="make_shared 创建方式"></a><code>make_shared</code> 创建方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        value = val;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Test object created.\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">Test</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Test object destroyed.\n&quot;</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::shared_ptr&lt;Test&gt; sp3 = std::<span class="hljs-built_in">make_shared</span>&lt;Test&gt;(<span class="hljs-number">1</span>);<br>    std::weak_ptr&lt;Test&gt; w4 = sp3;<br>    sp3.<span class="hljs-built_in">reset</span>();<br>    <span class="hljs-comment">// std::cout &lt;&lt; w4.lock()-&gt;value &lt;&lt; std::endl; //无法访问到</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012442.png" alt="image.png"></p><ul><li>可以发现raw ptr和control block的内存地址是相邻的</li></ul><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012147.png" alt="raw ptr的内存地址位置就在control block下方"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012419.png" alt="control block内存地址"></p><p>当执行了<code>sp3.reset()**;</code>** 后</p><p>weak ptr的raw ptr视图</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012495.png" alt="image.png"></p><p>weak ptr的control block视图</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052012728.png" alt="image.png"></p><p><strong>为什么访问不到value？</strong></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052013497.png" alt="虽然此时内存的value是1没错，但Test已经行将就木"></p><blockquote><p><code>expired()</code> is equivalent to <code>use_count() == 0</code>. The destructor for the managed object may not yet have been called, but this object’s destruction is imminent (or may have already happened).相当于use_count ( ) &#x3D;&#x3D; 0 。托管对象的析构函数可能尚未被调用，但该对象的销毁即将发生（或者可能已经发生）。</p></blockquote><p>Ref: <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr/expired">std::weak_ptr<T> ::已过期 - cppreference.com — std::weak_ptr<T>::expired - cppreference.com</a></p><h3 id="使用shared-from-this-√"><a href="#使用shared-from-this-√" class="headerlink" title="使用shared_from_this (√)"></a>使用shared_from_this (√)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getSharedPtr</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>(); <span class="hljs-comment">// 使用 enable_shared_from_this 的正确方式</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass instance&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 正确方式：使用 std::make_shared 创建 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj1 = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    <span class="hljs-comment">// 使用成员函数创建另一个共享的 shared_ptr</span><br>    std::shared_ptr&lt;MyClass&gt; obj2 = obj1-&gt;<span class="hljs-built_in">getSharedPtr</span>();<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052013086.png" alt="image.png"></p><h3 id="shared-ptr-weak-ptr伪代码实现"><a href="#shared-ptr-weak-ptr伪代码实现" class="headerlink" title="shared_ptr weak_ptr伪代码实现"></a><strong>shared_ptr weak_ptr伪代码实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">control_block</span><br>&#123;<br>    T* object;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Dispose</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    std::atomic&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt; shareds;<br>    std::atomic&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>&gt; weaks;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">shared_ptr</span><br>&#123;<br>    control_block&lt;T&gt;* control;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">weak_ptr</span><br>&#123;<br>    control_block&lt;T&gt;* control;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202411052013439.png" alt="image.png"></p><ul><li><code>strong ref</code> 和 <code>weak ref</code>是分别记录了此时指向该object的<code>shared_ptr</code>和 <code>weak_ptr</code>的个数。</li><li><code>_Uses</code> 和 <code>_Weaks</code> 是方便释放资源的计数。<code>_Uses</code> &#x3D; 强引用计数 <code>_Weaks</code> &#x3D; 弱引用计数 + <strong>bool(是否存在shared_ptr)</strong></li><li>也就是只要有 ≥ 1个<code>shared_ptr</code> 则<code>_Weaks</code>就要+1</li><li>这样做是为了方便只需要对<code>_Weaks</code>做一次原子检查就确定是否释放资源，而不需要分别检查<code>shared_ptr</code>个数和<code>weak_ptr</code>个数</li></ul><p>Ref: <a href="https://devblogs.microsoft.com/oldnewthing/20230814-00/?p=108597">STL 内部：智能指针 - 老新事物 — Inside STL: Smart pointers - The Old New Thing</a></p><p><a href="https://stackoverflow.com/questions/49585818/why-does-shared-ptr-needs-to-hold-reference-counting-for-weak-ptr">c++ - 为什么shared_ptr需要保存weak_ptr的引用计数？ - 堆栈溢出 — c++ - Why does shared_ptr needs to hold reference counting for weak_ptr? - Stack Overflow</a></p><h2 id="Bonus-Viewing"><a href="#Bonus-Viewing" class="headerlink" title="Bonus Viewing:"></a>Bonus Viewing:</h2><p><a href="https://www.reddit.com/r/cpp/comments/5do55l/heres_everything_i_know_about_shared_ptr/">这是我所知道的有关 shared_ptr 的所有内容：r&#x2F;cpp — Here’s everything I know about shared_ptr : r&#x2F;cpp</a></p><p> <a href="https://stackoverflow.com/questions/20895648/difference-in-make-shared-and-normal-shared-ptr-in-c">c++11 - C++中make_shared和普通shared_ptr的区别 - VoidCC — c++11 - Difference in make_shared and normal shared_ptr in C++ - Stack Overflow</a></p><p><a href="https://www.reddit.com/r/cpp/comments/pbiyre/comment/hac69lb/">仅使用引用计数来断言引用的寿命不会比对象长？ ：r&#x2F;cpp — Using reference counting only to assert that references do not outlive an object? : r&#x2F;cpp</a></p><p><a href="https://stackoverflow.com/questions/712279/what-is-the-usefulness-of-enable-shared-from-this">c++ - What is the usefulness of <code>enable_shared_from_this</code>? - Stack Overflow</a></p><p><a href="https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected">c++ - std::shared_ptr 内部结构，弱计数超出预期 - 代码日志 — c++ - std::shared_ptr internals, weak count more than expected - Stack Overflow</a></p><p><a href="https://stackoverflow.com/questions/5913396/why-do-stdshared-ptrvoid-work?rq=2">c++ - Why do std::shared_ptr<void> work - Stack Overflow</a>（神奇trick 类型擦除）</p><p><a href="https://www.reddit.com/r/cpp/comments/3eia29/comment/ctfeh1p/">std::shared_ptr 的秘密构造函数：r&#x2F;cpp — std::shared_ptr’s secret constructor : r&#x2F;cpp</a>（此发言没有指明任何锁操作，试图说明weak count如果不包含shared_ptr的计数（即只要存在sharedptr，weaks+1）就会出错，但是结合Chen的blog，顶多增加了原子检查的操作性能损耗。</p><p><a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2004/december/c-q-a-deleting-managed-objects-wrapping-a-library-and-more">C++ 问答：删除托管对象、包装库等 |微软学习 — C++ Q&amp;A: Deleting Managed Objects, Wrapping a Library, and More | Microsoft Learn</a> （太好了是微软开发杂谈）</p>]]></content>
    
    
    <categories>
      
      <category>C++parallel101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>RAII</tag>
      
      <tag>智能指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络幼儿科普读物01————internet/https</title>
    <link href="/2024/09/08/internet-https/"/>
    <url>/2024/09/08/internet-https/</url>
    
    <content type="html"><![CDATA[<h1 id="网络幼儿科普读物01"><a href="#网络幼儿科普读物01" class="headerlink" title="网络幼儿科普读物01"></a>网络幼儿科普读物01</h1><blockquote><p>审稿人: MrBeanC 阿里多多^^</p></blockquote><h2 id="curl-vs-ping"><a href="#curl-vs-ping" class="headerlink" title="curl vs ping"></a>curl vs ping</h2><ul><li><strong>curl</strong>：用于发送 HTTP&#x2F;HTTPS 等应用层协议的请求，并获取服务器响应，主要用于网络应用层的数据交互。</li><li><strong>ping</strong>：用于网络层的连接测试，通过 ICMP 协议确认目标设备是否可达，常用于诊断网络连通性问题。</li></ul><p><a href="https://superuser.com/questions/920491/why-does-curl-command-work-normally-while-ping-not">神奇问题：curl通ping不通（计算机网络真是太奇妙le）</a></p><h2 id="为什么需要域名访问？不直接用IP呢"><a href="#为什么需要域名访问？不直接用IP呢" class="headerlink" title="为什么需要域名访问？不直接用IP呢"></a>为什么需要域名访问？不直接用IP呢</h2><ul><li>输入域名浏览器会自动补充为https协议访问，域名会被解析为ip地址</li><li>域名是为了human-readable :) 服务器真实地址可能变化，例如服务器到期，or内网采用DDNS，但是用户只需要记住固定的域名</li></ul><blockquote><p>安全证书也可以给公共IP，保证IP的访问安全性~</p></blockquote><h3 id="私有-IP-地址范围"><a href="#私有-IP-地址范围" class="headerlink" title="私有 IP 地址范围"></a>私有 IP 地址范围</h3><p>根据 RFC 1918，以下三个 IP 地址范围被保留为私有地址：</p><p>私有地址 &#x3D;&#x3D; 不能在互联网中被路由</p><ol><li><strong>10.0.0.0 - 10.255.255.255</strong> （<code>10.x.x.x</code>）:<ul><li>支持的地址数量：16,777,216 个</li><li>通常用于大型企业网络</li></ul></li><li><strong>172.16.0.0 - 172.31.255.255</strong> （<code>172.16.x.x</code> 至 <code>172.31.x.x</code>）:<ul><li>支持的地址数量：1,048,576 个</li><li>通常用于中型企业网络</li></ul></li><li><strong>192.168.0.0 - 192.168.255.255</strong> （<code>192.168.x.x</code>）:<ul><li>支持的地址数量：65,536 个</li><li>通常用于家庭网络和小型企业网络</li></ul></li></ol><h3 id="HTTP请求是从哪个端口发出的"><a href="#HTTP请求是从哪个端口发出的" class="headerlink" title="HTTP请求是从哪个端口发出的"></a>HTTP请求是从哪个端口发出的</h3><ul><li><strong>客户端</strong>发起 HTTP 请求时，会从一个随机高位端口（49152-65535）发出。</li><li><strong>服务器</strong>接收 HTTP 请求的默认端口是 80（除非使用了其他自定义端口）。HTTPS是443端口。</li></ul><p><a href="https://www.golinuxcloud.com/set-up-proxy-http-proxy-environment-variable/">在 Linux 中使用 http_proxy 和 https_proxy 环境变量设置代理？</a></p><p>环境变量http_proxy https_proxy是会把对应的请求都发到值的ip端口上，由监听该端口的服务再进行转发</p><p><a href="https://about.gitlab.com/blog/2021/01/27/we-need-to-talk-no-proxy/">NO_PROXY</a></p><p><a href="https://superuser.com/questions/944958/are-http-proxy-https-proxy-and-no-proxy-environment-variables-standard">HTTP_PROXY、HTTPS_PROXY 和 NO_PROXY 环境变量是否标准</a> </p><h3 id="ip-端口-⇒-socket套接字"><a href="#ip-端口-⇒-socket套接字" class="headerlink" title="ip+端口 ⇒ socket套接字"></a>ip+端口 ⇒ socket套接字</h3><p>有了不同的端口分配给不同的进程，电脑可以进行多个进程运行和切换。端口会不会被占用玩完呢？几乎不可能噢，因为pc会维护端口，进程结束释放端口，并且一个端口可以处理一个程序的多个请求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>internet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>丑丑头像——个人博客评论系统valine部署小记</title>
    <link href="/2024/07/21/valine-comments/"/>
    <url>/2024/07/21/valine-comments/</url>
    
    <content type="html"><![CDATA[<h2 id="需求——个人博客网站评论区"><a href="#需求——个人博客网站评论区" class="headerlink" title="需求——个人博客网站评论区"></a>需求——个人博客网站评论区</h2><p>想要让自己的博客网站支持留言，装扮hexo空间:)</p><h2 id="对比技术——Gitalk-or-Valine-LeanCloud"><a href="#对比技术——Gitalk-or-Valine-LeanCloud" class="headerlink" title="对比技术——Gitalk or Valine+LeanCloud"></a>对比技术——<strong>Gitalk</strong> or Valine+LeanCloud</h2><blockquote><p>Gitalk 是一个基于 Github issues 的评论系统。</p></blockquote><p><strong>Gitalk steps:</strong></p><ul><li>注册一个新的 <strong>GitHub Application</strong> 来授权</li><li>修改config配置启用Gitalk</li></ul><p>通过Gitalk的readme，自动跳转到了OAuth application的注册界面，OAuth application不等同于Github application。虽然两者都是为了能够暴露GitHub的仓库操作API，OAuth application并不能限制使用GitHub的权限限度。OAuth application可以类比qq授权给另一个网站登录使用qq的个人信息，OAuth application的回调（callback）url就是个人博客网站url，即接收GitHub发送的token的一方。由于hexo的明文传输，这个token理论上是会被暴露在前端的某个js文件中</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341648.png" alt="screenshot"></p><p><strong>暴露是否是安全呢？答案：so far so good</strong></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341908.png" alt="Untitled"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341874.png" alt="Untitled"></p><ul><li>关键在于callback url不可改，指向的我们自己的博客是受信任的，安全的。但是当我们点别人的博客提示需要授权的时候，就要小心了</li></ul><p><a href="https://github.com/gitalk/gitalk/issues/444">https://github.com/gitalk/gitalk/issues/444</a></p><p><strong>token权限争议</strong></p><ul><li>引用的博主认为：OAuth application使用的token应该是仅有只读权限 但是这位博主自己的评论区进行GitHub授权时，依然提示需要授权read and write。引用：<a href="https://carl-zk.github.io/blog/2020/03/03/gitalk-%E8%BF%90%E4%BD%9C%E5%8E%9F%E7%90%86/">Gitalk 运作原理 | 一叶轻舟渡万江 (carl-zk.github.io)</a></li></ul><p>OAuth App 5年前创建，2019年，此时PR还没提，还是read write</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341044.png" alt="Untitled"></p><p>2020.2 PR合并，token的权限从读写权改为read only </p><p><a href="https://github.com/gitalk/gitalk/pull/344">https://github.com/gitalk/gitalk/pull/344</a></p><p>2020.3博主调查之后 写下read only的结论</p><p><strong>Valine+LeanCloud steps:</strong> </p><ul><li>注册LeanCloud<a href="https://console.leancloud.cn/apps">LeanCloud</a></li><li>参考stun主题的valine部署方式<a href="https://theme-stun.github.io/docs/zh-CN/advanced/third-part.html#valine">第三方支持 | hexo-theme-stun</a></li></ul><p>对比Gitalk和Valine，Gitalk有一定的风险w 而Valine虽然不一定稳定，但是删库跑路的风险是0.0000001。所以选择Valine＜（＾－＾）＞</p><h2 id="头像是丑丑人儿怎么办呢"><a href="#头像是丑丑人儿怎么办呢" class="headerlink" title="头像是丑丑人儿怎么办呢"></a>头像是丑丑人儿怎么办呢</h2><p>当完成了评论区的基本部署，需要选择默认头像样式。这里可以选择神秘人样式，或者wavatar小怪物。但是没有人想到当VPN+无邮箱测试留言评论，头像是丑丑人儿！（在配置中命名配置的是wavatar！）</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212340677.png" alt="Untitled"></p><p>小坑：需要注意notify：verify：类似这种的配置文件有列出的项目，不能直接注释掉（这是必须项）应该写false来禁用</p><p>经过和cls的一个下午测试，结论如下：</p><ol><li>丑丑人是not found&#x2F;网络情况不佳等异常的fallback（302）</li><li>不开梯子反而可以看到正常人（mp）也可以有wavatar</li><li>wavatar需要填写qq邮箱 每个邮箱随机对应一个wavatar</li><li>不填写邮箱只能显示mp（or丑丑人）</li><li><code>enableQQ</code>在配置中是无效的</li><li>在开VPN情况下，填写邮箱，可以正确加载头像，这并不是网络原因，只是米有了邮箱用于标识造成的not found (bug maybe)</li></ol><p>一言蔽之：只有在<code>VPN + 无邮箱</code>的情况下，才会显示丑人 (302)</p><p>一旦生成头像，会永久和邮箱绑定</p><p>疑惑：为什么有VPN反而not found (302)</p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341687.png" alt="Untitled"></p><p><img src="https://raw.githubusercontent.com/pinkyrie/pic/main/202407212341955.png" alt="Untitled"></p><p>aa 没有mail都是丑丑人儿！</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><p><a href="https://valine.js.org/avatar.html">头像配置 | Valine 一款快速、简洁且高效的无后端评论系统。</a>(我们会发现这个里面评论区头像图片获取的链接和我们使用的头像获取url不太一样呢）</p><p><a href="https://theme-stun.github.io/docs/zh-CN/advanced/third-part.html#valine">第三方支持 | hexo-theme-stun</a></p><p><a href="https://github.com/gitalk/gitalk/issues?page=1&q=secret">https://github.com/gitalk/gitalk/issues?page=1&q=secret</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>valine blog-comments</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
